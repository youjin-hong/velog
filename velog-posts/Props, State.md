<p>props와 state의 개념에 대해서는 대충 알고 있었지만 이 둘이 어떤 연관이 있는지, 어떻게 동작하는 것인지, prop drilling이라는 단어를 들으면 머리에 물음표만 가득해서 개념부터 이해하기 위해 글로 정리하게 되었다. </p>
<p>props와 state는 react에서 데이터를 사용할 때 다루는 개념으로, props를 통해 부모 컴포넌트의 state를 자식 컴포넌트에 전달하는 방식이다.</p>
<hr />
<h4 id="state">[state]</h4>
<p>state는 컴포넌트 &quot;내부&quot;에서 관리되는 값으로 &quot;변경 가능&quot;하다. 
쉽게 말해, state는 렌더링되는 동안 값이 변할 수 있고, 변경될 때마다 컴포넌트가 다시 렌더링 된다. </p>
<p>즉, React에서 state는 </p>
<ul>
<li><strong>컴포넌트 내에서 관리되는 상태 데이터</strong>이며, 컴포넌트 내부에서 변경할 수 있고</li>
<li>컴포넌트 내부에서 변경할 수 있으며,</li>
<li>컴포넌트의 렌더링 결과를 결정한다. </li>
</ul>
<p><strong>state의 장점</strong>은 </p>
<p>1) 컴포넌트 내부 상태를 유지할 수 있다.</p>
<p>2) 동적인 UI를 구성할 수 있다. 
-&gt; 상태 데이터를 사용해 입력에 대한 반응을 보여주거나, 외부 API에서 데이터를 가져와 화면을 업데이트 할 수 있다. 
(카운터 앱을 예시로 들어보면 현재 카운터값이 보이고, 증가/감소 버튼을 누르면 값이 그에따라 증감하는 것을 볼 수 있다.)
<img alt="" src="https://velog.velcdn.com/images/so356hot/post/8084b347-6676-400b-9b9e-e1c7de06359f/image.png" />
여기서 +100을 누르면 현재 카운트가 바뀌는 것을 바로 확인할 수 있다
<img alt="" src="https://velog.velcdn.com/images/so356hot/post/a15ab0cb-6c95-4970-9b8b-746d9a1834be/image.png" />
3) React의 렌더링 성능을 최적화할 수 있다.(최적화에 대한 글은 뒤에 쓸 것이다.)
react는 컴포넌트의 상태가 변경될 때만 렌더링을 다시 수행하기 때문에 상태 데이터를 이용해 불필요한 렌더링을 방지할 수 있다. </p>
<p>반대로 <strong>state의 단점</strong>도 존재하는데, </p>
<p>1) state의 관리가 어려울 수 있다는 것이다. 
state는 컴포넌트에서 UI의 상태를 관리하는데 사용되기 때문에, 컴포넌트가 복잡해질 수록 관리하기 어려워진다. 
즉, 상태가 변경될 때마다 컴포넌트의 렌더링이 다시 일어나기 때문에 상태가 변경되는 빈도가 높으면 성능 문제가 발생할 수 있다. </p>
<p>2) state가 공유되지 않는다. 
위에서 말했듯이 state는 컴포넌트 내부에서 상태를 관리하는 값이기 때문에 컴포넌트 간의 state는 불가능하다. 
이는 컴포넌트 간에 데이터를 전달할 때, <strong>&quot;props&quot;</strong>를 사용해야 함을 의미한다.</p>
<p>3) state의 중복이 발생할 수 있다. 
여러 컴포넌트에서 같은 상태를 사용해야 하는 경우에 주로 발생하는데, 이 때 중복된 상태를 사용하게 되면 업데이트 하는 것이 어려워질 수 있고, 코드 가독성과 유지보수성이 저하될 수 있다. </p>
<p>중복 문제를 해결하기 위해서는 다음과 같은 방법들이 있다.</p>
<ul>
<li>관련된 자식 컴포넌트들이 공유하는 가장 가까운 공통 부모 컴포넌트로 state를 <strong>끌어올리기</strong>를 하는 방법이 있고,</li>
<li>React의 <strong>contextAPI</strong>를 사용해 다양한 레벨에 걸쳐 있는 컴포넌트들 간에 state를 공유하는 방법이 있다. </li>
<li>그 외에 redux와 같은 <strong>상태 관리 라이브러리</strong>를 사용하는 방법으로 애플리케이션의 상태를 중앙에서 관리해 여러 컴포넌트가 쉽게 접근하고 업데이트할 수 있도록 도와준다고 한다.</li>
</ul>
<p>4) state의 불변성을 유지해야 한다. 
유지해야 하는 이유는 성능 최적화, 버그 방지, 코드 유지보수가 있다. </p>
<p>react는 React.memo와 같은 최적화 도구를 제공하는데, 이 도구는 props나 state가 변경되었는지를 &quot;얕은 비교&quot;를 통해 판단하고, 변화가 없다면 불필요한 리렌더링을 방지한다. state의 불변성을 유지한다면 이러한 비교가 정확하게 이뤄지고, 성능이 개선된다. </p>
<p>또한 직접적으로 state를 수정하면 이전 state와 새로운 state가 동일한 참조를 공유하게 되어 예상치 못한 오류가 발생할 수 있다. 불변성을 유지하면 이전 상태의 참조를 유지하며 상태 변화를 추적할 수 있어 디버깅이 쉬워진다. </p>
<p>마지막으로, 불변성을 유지하면 데이터 흐름이 명확해지고, 어플리케이션의 상태 관리가 더 예측 가능해짐으로써 코드 유지보수가 향상된다. </p>
<p>5) state의 크기가 커지면 성능 문제가 발생할 수 있다. 
컴포넌트의 state가 매우 큰 겨우에 상태 업데이트를 처리하는 데 많은 시간이 소요될 수 있다. 이 경우에는 상태를 분할하거나, 최적화하는 것이 필요할 수 있다. </p>
<hr />
<h4 id="props">[Props]</h4>
<p>props는 부모 -&gt; 자식 컴포넌트로 데이터가 전달되는 값으로서, 직접 수정할 수 없는 &quot;읽기 전용&quot;의 값이다. 
이는 컴포넌트를 불변적으로 만들어주기 때문에 컴포넌트 간에 데이터를 전달하고, 컴포넌트를 재사용하는 데에 유용하다. </p>
<blockquote>
</blockquote>
<ul>
<li>props는 불변하다</li>
<li>컴포넌트 내에서 수정할 수 없다.</li>
<li>props는 부모 -&gt; 자식 컴포넌트로 데이터를 전달해야 한다.</li>
</ul>
<p>자식 컴포넌트에서 props를 사용할 땐, this.props를 사용하거나 함수형 컴포넌트에서 인자로 전달 받는다. </p>
<p>props의 <strong>장점</strong>은 아래와 같다.</p>
<p>1) 데이터의 일관성을 유지할 수 있다. 
예를 들어, 한 부모 객체에서 폰트 사이즈에 대한 속성을 갖고 헤더, 콘텐츠, 푸터의 자식 컴포넌트에게 전달한다고 하자.
각 자식 컴포넌트는 전달받은 폰트 사이즈를 바탕으로 전체 애플리케이션의 글꼴 크기가 일관되게 유지할 수 있다. </p>
<p>2) 재사용성이 높아진다.</p>
<p>3) 유지보수가 용이하다. </p>
<p>반대로 props의 <strong>단점</strong>은 아래와 같다.</p>
<p>1) props는 부모 -&gt; 자식으로 단방향흐름의 &quot;읽기 전용&quot;이기 때문에 자식 컴포넌트는 전달받은 props를 직접 수정할 수 없다.
이는 데이터의 일관성과 예측 가능성을 유지하는 데 도움을 주지만, 데이터 흐름의 복잡성을 야기할 수 있다. 
예를 들어, 자식 컴포넌트에서 발생한 사용자의 입력이나 상태의 변경이 필요한 경우, 그 변경사항을 부모 컴포넌트에 알리고, 부모 컴포넌트가 새로운 props를 자식에게 내려보내는 방식으로 데이터를 갱신해야 한다. 
이 과정은 여러 단계로 중첩된 컴포넌트 구조에서 특히나 복잡해질 수 있다. </p>
<p>2) props의 전달이 과하게 많아질 수 있다. </p>
<p>1) 에서 말했듯이 중첩 수준이 깊어질수록 코드 가독성이 저하될 수 있다. 이 경우엔 context API나 redux와 같은 상태관리 라이브러리를 사용하는 것이 방법일 수 있다. </p>
<p>3) props가 공유되지 않는다.
이게 무슨 말이냐면 props는 react에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 <strong>&quot;전달&quot;</strong>할 수 있게 해주는 거지 props가 직접적으로 &quot;자식 간&quot;에 공유되지 않는다는 것이다. 
아래의 예시 코드를 보자.</p>
<pre><code class="language-javascript">function Parent() {
    const userInfo = { name: &quot;John&quot;, age: 30 };

    return (
        &lt;div&gt;
            &lt;ChildA userInfo={userInfo} /&gt;
            &lt;ChildB userInfo={userInfo} /&gt;
        &lt;/div&gt;
    );
}</code></pre>
<p>2개의 자식 컴포넌트 ChildA와 ChildB는 Parent 컴포넌트에 저장되어 있다. 
여기서 UserInfo는 Parent 컴포넌트에서 2개의 자식 컴포넌트에게 동일하게 전달된다. 
각 자식 컴포넌트는 UserInfo를 받아 처리하지만, 이 정보를 서로 직접 공유하거나 다른 컴포넌트로부터 받을 수는 없다. 
모든 정보의 소스는 Parent 컴포넌트로부터 나와야 한다. </p>
<p>4) props의 이름 충돌이 발생할 수 있다. 
여러 컴포넌트에서 동일한 이름의 props를 사용하는 경우 props의 이름 충돌이 발생할 수 있다. </p>
<hr />
<h4 id="react-컴포넌트가-rerendering-되는-조건">[react 컴포넌트가 rerendering 되는 조건]</h4>
<ul>
<li>자신이 관리하는 <strong>state</strong>가 변경되었을 때</li>
<li>자신이 제공받는 <strong>props</strong>가 변경되었을 때</li>
<li><strong>부모</strong> 컴포넌트가 리렌더링 되면 <strong>자식</strong> 컴포넌트도 리렌더링 된다.</li>
<li><blockquote>
<p>부모 컴포넌트가 리렌더링 되면서 자식 컴포넌트도 리렌더링이 되기 때문에 
우리가 리렌더링 시키고자 하는 컴포넌트 외에 다른 컴포넌트들도 불필요하게 리렌더링 될 수가 있다.
따라서 관련 없는 컴포넌트들은 서로 다른 컴포넌트들로 빼줄 필요가 있다. </p>
</blockquote>
</li>
</ul>
<p>불필요한 리렌더링을 방지하기 위해서는 최적화 기법을 사용할 수 있는데 이것은 뒷장에서 다뤄보도록 하겠다. </p>
<hr />
<h4 id="최종-정리">[최종 정리]</h4>
<p>1) React에서 화면을 구성할 때, 여러 개의 컴포넌트들이 부모와 자식 관계를 이루며 계층 구조를 형성한다. 
2) 특정 컴포넌트가 다른 컴포넌트에게 데이터를 전달하려면 반드시 그 관계가 <strong>부모-자식</strong> 관계를 갖고 있어야 한다. 이는 props를 &quot;전달&quot;하는 것이기 때문이다. 
3) 그렇기 때문에 하나의 state를 여러 컴포넌트에서 관리하게 될 경우, 
공통 부모가 되는 컴포넌트에 만드는 것이 좋다. </p>
<p>=&gt; state를 계층구조 상에서 위로 끌어올려서 아래에 있는 컴포넌트들이 모두 공유할 수 있게 하는 것을 <strong>State Lifting (state 끌어올리기)</strong>라고 한다. </p>
<p><img alt="" src="https://velog.velcdn.com/images/so356hot/post/3f0cd212-0afe-40b0-b1b8-f7060aa76256/image.png" />
이는 react는 데이터가 &quot;단방향&quot;으로 흐르기 때문에 state를 어느 컴포넌트에 위치시킬 건지 잘 고려하는 것이 중요하다는 것을 의미한다. </p>