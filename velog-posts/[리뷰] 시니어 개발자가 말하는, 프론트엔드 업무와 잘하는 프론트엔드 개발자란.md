<h2 id="📚-오늘의-아티클">📚 오늘의 아티클</h2>
<p><a href="https://yozm.wishket.com/magazine/detail/1294/">시니어 개발자가 말하는, 프론트엔드 업무와 잘하는 프론트엔드 개발자란</a></p>
<h2 id="📖-내용-요약">📖 내용 요약</h2>
<p>마이크로서비스 아키텍처(MSA)에서 서비스 간 통신은 크게 동기식(Synchronous)과 비동기식(Asynchronous) 두 가지 방식으로 나눌 수 있습니다.</p>
<h3 id="동기식-통신">동기식 통신</h3>
<ul>
<li>HTTP/REST를 사용한 요청-응답 방식</li>
<li>서비스 A가 서비스 B를 호출하고 응답을 기다림</li>
<li>실시간 응답이 필요한 경우에 적합</li>
<li>장점: 구현이 단순하고 직관적</li>
<li>단점: 응답 대기 시간 발생, 서비스 간 결합도가 높아짐</li>
</ul>
<h3 id="비동기식-통신">비동기식 통신</h3>
<ul>
<li>메시지 큐(Kafka, RabbitMQ 등)를 사용</li>
<li>이벤트 기반 통신 방식</li>
<li>서비스 A가 메시지를 발행하고 작업 계속 진행</li>
<li>장점: 서비스 간 결합도가 낮고, 확장성이 좋음</li>
<li>단점: 시스템 복잡도 증가, 디버깅이 어려움</li>
</ul>
<h2 id="🤔-나의-생각">🤔 나의 생각</h2>
<p>이 아티클을 읽으면서 현재 우리 팀 프로젝트에서 겪고 있는 문제와 연관성을 발견했습니다. 우리는 지금 모든 서비스 간 통신을 REST API로 처리하고 있는데, 특히 주문 처리 과정에서 결제 서비스와의 동기식 통신이 성능 병목이 되고 있습니다.</p>
<p>결제 처리는 꼭 실시간으로 완료될 필요가 없으므로, 비동기 방식으로 전환하면 좋을 것 같습니다. 예를 들어:</p>
<ol>
<li>주문 서비스가 &quot;주문_생성&quot; 이벤트를 발행</li>
<li>결제 서비스가 이벤트를 구독하여 비동기적으로 결제 처리</li>
<li>결제 완료 후 &quot;결제_완료&quot; 이벤트를 발행</li>
<li>주문 서비스가 이벤트를 구독하여 주문 상태 업데이트</li>
</ol>
<p>이런 방식으로 변경하면 주문 서비스가 결제 처리를 기다리지 않아도 되어 전체적인 응답 시간이 개선될 것 같습니다.</p>
<h2 id="💡-추가로-공부할-내용">💡 추가로 공부할 내용</h2>
<ul>
<li>Apache Kafka vs RabbitMQ 비교</li>
<li>이벤트 기반 아키텍처의 데이터 일관성 보장 방법</li>
<li>비동기 통신에서의 에러 처리 전략</li>
</ul>
<h2 id="🔖-참고할만한-자료">🔖 참고할만한 자료</h2>
<ul>
<li><a href="https://yozm.wishket.com/magazine/detail/1289/">시니어 개발자가 말하는, 프론트엔드 역사와 미래</a></li>
<li><a href="https://api.velog.io/rss/%EB%A7%81%ED%81%AC">마이크로서비스 패턴</a> by Chris Richardson</li>
</ul>