# 📌 Velog 글 요약

| 항목   | 내용 |
|--------|------|
| **제목** | 클래스 컴포넌트를 공부하며 깨달은 리액트 훅의 간편함 |
| **날짜** | Sat, 16 Aug 2025 10:29:58 GMT |
| **링크** | [https://velog.io/@so356hot/React-Hooks-%EB%8F%84%EC%9E%85-%EB%8F%99%EA%B8%B0%EB%B6%80%ED%84%B0-%EC%9D%91%EC%9A%A9-%EC%98%88%EC%A0%9C%EA%B9%8C%EC%A7%80-%EB%8B%A4%EB%A4%84%EB%B3%B4%EA%B8%B0](https://velog.io/@so356hot/React-Hooks-%EB%8F%84%EC%9E%85-%EB%8F%99%EA%B8%B0%EB%B6%80%ED%84%B0-%EC%9D%91%EC%9A%A9-%EC%98%88%EC%A0%9C%EA%B9%8C%EC%A7%80-%EB%8B%A4%EB%A4%84%EB%B3%B4%EA%B8%B0) |

---

<p>TDD를 공부하면서 props와 state를 이해하기 위해 클래스 컴포넌트에 대해 간단히 클론코딩하면서 함수형 컴포넌트랑 비교하는 단원이 있었는데, 평소에 클래스로 컴포넌트를 스스로 개발해본 적도 없고 리액트 훅도 useState, useEffect를 주로 쓰고 그 외의 훅들은 거의 써본 경험이 없어서 이번 기회에 클래스 컴포넌트 vs 함수 컴포넌트, react hook의 도입 동기, 대표적인 react 훅, 그리고 최적화를 위한 hook, 마지막으로 커스텀 hook에 대해 살펴보고 간단한 응용 예제까지 직접 작성해보는 시간을 가져보려고 합니다.</p>
<h2 id="1-react-hooks가-등장한-이유">1. React Hooks가 등장한 이유</h2>
<blockquote>
<p><strong>도입 배경 요약</strong></p>
</blockquote>
<ul>
<li>복잡한 클래스 컴포넌트 단순화</li>
<li>코드 재사용성 향상</li>
</ul>
<p>React 16.8 이전까지는 상태 관리와 생명주기를 모두 클래스 컴포넌트 내에서 이루어졌습니다. 그러나 클래스 컴포넌트는 this 바인딩 문제, 컴포넌트 로직 재사용 어려움, 생명주기 메서드의 복잡성 등의 여러 단점이 있어 개발자들의 러닝 커브가 컸다고 합니다. 그러다 React에서 16.8 버전부터 <strong>Hook</strong>을 새롭게 도입하며 함수형 컴포넌트를 표준으로 두어 이 방법을 적극 사용할 것을 권장하고 있습니다.
<img alt="" src="https://velog.velcdn.com/images/so356hot/post/ee61e8ae-11d9-4a96-baa9-e4ef81052135/image.png" /></p>
<p>함수형 컴포넌트에 대해 처음 공부할 때 클래스 컴포넌트에 대해서도 어느 정도 이해하는 것이 함수형 컴포넌트를 더 잘 이해하는 데에 도움이 되기 때문에 클래스 컴포넌트 사용 방법, 클래스 컴포넌트 라이프 사이클 함수 종류 등에 대해 간단히 알아두시면 좋을 것 같습니다. </p>
<p>클래스 컴포넌트에 대한 개념과 라이프 사이클 함수 종류에 대해서는 코드와 함께 정리해두었으니 아래 포스트를 참고하면 좋을 것 같습니다.</p>
<p>➡️ <a href="https://velog.io/@so356hot/%EC%8A%A4%EB%AC%B4%EB%94%94-%ED%95%9C-%EC%9E%94-%EB%A7%88%EC%8B%9C%EB%A9%B0-%EB%81%9D%EB%82%B4%EB%8A%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-TDD-7%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8">스무디 한 잔 마시며 끝내는 리액트 + TDD 7장 - 클래스 컴포넌트</a></p>
<h3 id="클래스형-컴포넌트-vs-함수형-컴포넌트">클래스형 컴포넌트 VS 함수형 컴포넌트</h3>
<table>
<thead>
<tr>
<th align="left">특징</th>
<th align="left">클래스형 컴포넌트</th>
<th align="left">함수형 컴포넌트</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>문법</strong></td>
<td align="left">ES6 클래스</td>
<td align="left">Javascript 함수</td>
</tr>
<tr>
<td align="left"><strong>상태 관리</strong></td>
<td align="left"><code>this.state</code>, <code>this.setState()</code></td>
<td align="left"><code>useState</code> 훅</td>
</tr>
<tr>
<td align="left"><strong>생명 주기</strong></td>
<td align="left">개별 메서드 사용 (<code>componentDidMount</code>, <code>componentDidUpdate</code> 등)</td>
<td align="left"><code>useEffect</code> 훅으로 통합 관리</td>
</tr>
<tr>
<td align="left"><strong><code>this</code> 키워드</strong></td>
<td align="left">사용해야 함</td>
<td align="left">불필요</td>
</tr>
<tr>
<td align="left"><strong>코드 스타일</strong></td>
<td align="left">상대적으로 길고 복잡함</td>
<td align="left">간결하고 읽기 쉬움</td>
</tr>
</tbody></table>
<br />


<pre><code class="language-jsx">// 클래스 컴포넌트 예시: state + lifecycle
class Counter extends Component {
  state = { count: 0 };

  componentDidMount() {
    console.log('Mounted!');
  }

  render() {
    return &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
      {this.state.count}
    &lt;/button&gt;;
  }
}

// 함수형 컴포넌트 예시: Hooks로 변환
import { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; console.log('Mounted!'), []);

  return &lt;button onClick={() =&gt; setCount(prev =&gt; prev + 1)}&gt;{count}&lt;/button&gt;;
}</code></pre>
<br />

<h2 id="2-hooks의-기본-원칙과-잘못된-사용-예시">2. Hooks의 기본 원칙과 잘못된 사용 예시</h2>
<p>훅은 <code>useState</code>, <code>useEffect</code>와 같이 <code>use</code>로 시작하는 함수들을 말합니다. </p>
<blockquote>
<p>이런 리액트 훅에는 <strong>두 가지의 핵심 규칙</strong>이 있습니다:
✔️ <strong>최상위 레벨</strong>에서만 호출할 것, 
✔️ <strong>함수형 컴포넌트나 Custom Hook 안에서만</strong> 호출할 것.</p>
</blockquote>
<pre><code class="language-jsx">function Counter() {
  // 🟢 Good: 함수 컴포넌트의 최상위 레벨에서 사용합니다.
  const [count, setCount] = useState(0);
  // ...
}

function useWindowWidth() {
  // 🟢 Good: 커스텀 Hook의 최상위 레벨에서 사용합니다.
  const [width, setWidth] = useState(window.innerWidth);
  // ...
}</code></pre>
<p>위의 규칙은 리액트 공식문서에 명시되어 있는데요. 이러한 규칙을 어기면 React의 렌더링 순서 추적이 깨져 버그가 발생합니다.
규칙을 어기는 간단한 예시를 살펴보겠습니다.</p>
<pre><code class="language-jsx">function Bad({ condition }) {
  if (condition) {
    // 🔴 Bad: 조건문 내부
    const theme = useContext(ThemeContext);
  }
}

function Bad() {
  for (let i = 0; i &lt; 10; i++) {
    // 🔴 Bad: 반복문 내부
    const theme = useContext(ThemeContext);
  }
}

function Bad({ condition }) {
  if (condition) {
    // 🔴 Bad: 조건문 &quot;return&quot;문 이후
    const theme = useContext(ThemeContext);
  }
}

function Bad() {
  const handleClick = () =&gt; {
    // 🔴 Bad: 이벤트 핸들러 내부
    const theme = useContext(ThemeContext);
  };
}

class Bad extends Component {
  render() {
    // 🔴 Bad: 클래스 컴포넌트 내부
    useEffect(() =&gt; {});
  }
}

function Bad() {
  try {
    // 🔴 Bad: try/catch/finally 블록 내부 (외부로 이동)
    const [x, setX] = useState(0);
  } catch (e) {
    const [x, setX] = useState(1);
  }
}</code></pre>
<p>이런 규칙을 어기는 실수를 방지하기 위해 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a> 플러그인을 사용할 수 있습니다.</p>
<br />

<h2 id="3-기본적인-핵심-hooks">3. 기본적인 핵심 Hooks</h2>
<h3 id="31-usestate">3.1 useState</h3>
<blockquote>
<p><code>useState</code>는 컴포넌트에 상태를 추가하는 가장 기본적인 훅으로, setState를 통해 값을 초기화하거나 업데이트합니다.</p>
</blockquote>
<pre><code class="language-jsx">const [count, setCount] = useState(0);

// 직접 값 업데이트
setCount(10);

// 함수형으로 값 업데이트 (이전 상태를 기반할 때)
setCount(prev =&gt; prev + 1);

// 객체/배열 상태 관리
const [user, setUser] = useState({name: '', age: 0});
setUser(prev =&gt; ({ ...prev, name: 'Ujin' });</code></pre>
<blockquote>
<p><strong>주의 사항</strong></p>
</blockquote>
<ul>
<li>상태 업데이트는 비동기적으로 발생</li>
<li>객체/배열을 업데이트할 때는 항상 새로운 객체/배열 만들어야 함 (불변성 유지)</li>
<li>여러 번의 setState가 batching되어 한 번에 처리됨</li>
</ul>
<br />

<h3 id="32-useeffect">3.2 useEffect</h3>
<blockquote>
<p><code>useEffect</code>는 컴포넌트가 렌더링된 뒤 실행되는 부수효과(side effect)를 처리하는 훅으로, API 요청, DOM 조작에 활용되며 <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>에 해당하는 작업을 수행합니다.</p>
</blockquote>
<pre><code class="language-jsx">// 컴포넌트 마운트 시에만 실행 (componentDidMount)
useEffect(() =&gt; {
  console.log('컴포넌트가 마운트됨')
}, []);

// 특정 state 변경 시에만 실행
useEffect(() =&gt; {
  console.log('count가 변경됨')
}, [count]);

// cleanup 함수로 메모리 누수 방지 (componentWillUnmount)
useEffect(() =&gt; {
  const id = setInterval(() =&gt; console.log('Tick'), 1000);

  // cleanup 함수
  return () =&gt; {
    clearInterval(id);
    console.log('타이머가 정리됨')
  };
}, []);

// 의존성 배열 없이 사용 (매 렌더링마다 실행)
useEffect(() =&gt; {
  document.title = `Count: ${count}`;
});</code></pre>
<blockquote>
<p><strong>의존성 배열 패턴</strong></p>
</blockquote>
<ul>
<li><code>[]</code>: 마운트 시 한 번만 실행</li>
<li><code>[count]</code>: count가 변경될 때마다 실행</li>
<li>생략: 매 렌더링마다 실행</li>
</ul>
<br />

<h3 id="33-usecontext">3.3 useContext</h3>
<blockquote>
<p><code>useContext</code>는 Context API와 함께 사용하여 컴포넌트 트리 전체에 데이터를 전달하는 훅으로, prop drilling 문제를 해결해줍니다.</p>
</blockquote>
<pre><code class="language-jsx">// Context 생성
const ThemeContext = createContext();

// Provider로 감싸기
function App() {
  const [theme, setTheme] = useState('light');

  return (
    &lt;ThemeContext.Provider value={{theme, setTheme}}&gt;
      &lt;Header /&gt;
      &lt;Main /&gt;
    &lt;/ThemeContext.Provider&gt;
    );
};

// Context 사용
function Header() {
  const {theme, setTheme} = useContext(ThemeContext);

  return (
    &lt;header className={theme}&gt;
      &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;
        테마 변경
      &lt;/button&gt;
    &lt;/header&gt;
    );
}</code></pre>
<p>사용방법은 따로 정리해두었으니 링크 타고 들어가서 보시면 될 것 같습니다. 
➡️ <a href="https://velog.io/@so356hot/%EC%8A%A4%EB%AC%B4%EB%94%94-%ED%95%9C-%EC%9E%94-%EB%A7%88%EC%8B%9C%EB%A9%B0-%EB%81%9D%EB%82%B4%EB%8A%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-TDD-8%EC%9E%A5-Context-API%EC%99%80-localStorage">스무디 한 잔 마시며 끝내는 리액트 TDD 8장 - Context API</a></p>
<br />

<h2 id="4-알아두면-좋은-hooks">4. 알아두면 좋은 Hooks</h2>
<h3 id="41-usereducer">4.1 useReducer</h3>
<blockquote>
<p><code>useReducer</code>는 복잡한 상태 로직을 관리할 때 <code>useState</code>보다 더 예측 가능한 상태 업데이트를 제공합니다. Redux와 유사한 패턴으로 작동합니다.</p>
</blockquote>
<pre><code class="language-jsx">// reducer 함수 정의
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }   
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({type: 'reset'})}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
    );
}</code></pre>
<blockquote>
<p><strong>언제 useReducer을 사용할 지?</strong></p>
</blockquote>
<ul>
<li>상태 구조가 복잡할 때</li>
<li>상태 업데이트 로직이 복잡할 때</li>
<li>여러 컴포넌트에서 같은 상태 로직을 공유할 때</li>
<li>테스트하기 쉬운 순수함수로 상태 로직을 분리하고 싶을 때</li>
</ul>
<br />

<h3 id="42-usememo--usecallback">4.2 useMemo &amp; useCallback</h3>
<blockquote>
<p><code>useMemo</code>와 <code>useCallback</code>은 성능 최적화를 위한 훅으로, 불필요한 계산과 함수 재생성을 방지하여 컴포넌트 리렌더링을 줄입니다.</p>
</blockquote>
<pre><code class="language-jsx">function ExpensiveComponent({ items, filter}) {
  // 비싼 계산을 메모이제이션
  const expensiveValue = useMemo(() =&gt; {
    return items.
        .filter(item =&gt; item.category === filter)
        .reduce((sum, item) =&gt; sum + item.price, 0);
  }, [items, filter]);

  // 함수를 메모이제이션 (자식 컴포넌트 리렌더링 방지)
  const handleClick = useCallback((id) =&gt; {
    console.log('item clicked:', id);
  }, []);

  return (
    &lt;div&gt;
      &lt;h3&gt;Total: ${expensiveValue}&lt;/h3&gt;
      {items.map(item =&gt; (
        &lt;Item 
          key={item.id}
          item={item}
          onClick={handleClick}
          /&gt;
        ))}
      &lt;/div&gt;
    );
}

// 메모이제이션된 컴포넌트
const Item = memo(({ item, onClick }) =&gt; {
  return &lt;div onClick={() =&gt; onClick(item.id)}&gt;{item.name}&lt;/div&gt;
});</code></pre>
<blockquote>
<p><strong>주의 사항</strong></p>
</blockquote>
<ul>
<li>모든 곳에서(무분별하게) 사용하면 오히려 성능 저하 우려</li>
<li>정말 비싼 계산이나 자식 컴포넌트 리렌더링이 문제가 될 때만 사용</li>
<li>의존성 배열을 정확하게 설정</li>
</ul>
<br />

<h3 id="43-useref">4.3 useRef</h3>
<blockquote>
<p><code>useRef</code>는 DOM 요소에 직접 접근하거나, 렌더링과 관계없이 값을 보존해야 할 때 사용하는 훅으로, <code>.current</code> 프로퍼티를 통해 값에 접근합니다.</p>
</blockquote>
<pre><code class="language-jsx">function TextInput() {
  const inputRef = useRef(null);
  const countRef = useRef(0);

  const focusInput = () =&gt; {
    inputRef.current.focus();
  };

  const handleClick = () =&gt; {
    countRef.current += 1;
    console.log('클릭 횟수:', countRef.current);
  };

  return (
    &lt;div&gt;
      &lt;input ref={inputRef} type=&quot;text&quot; placeholder=&quot;여기에 입력하세요&quot; /&gt;
      &lt;button onClick={focusInput}&gt;입력창 포커스&lt;/button&gt;
      &lt;button onClick={handleClick}&gt;클릭 카운트 (콘솔 확인)&lt;/button&gt;
      &lt;p&gt;클릭해도 화면은 다시 그려지지 않습니다&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
<blockquote>
<p><strong>useRef vs useState</strong></p>
</blockquote>
<ul>
<li><code>useRef</code>: 값이 변해도 리렌더링되지 않음. DOM 조작에 주로 사용</li>
<li><code>useState</code>: 값이 변하면 리렌더링됨. 화면에 표시되는 데이터에 사용</li>
</ul>
<br />

<h3 id="44-기타-유용한-hooks">4.4 기타 유용한 Hooks</h3>
<p>기본 Hooks만으로도 대부분의 상태 관리가 가능하지만, 특정 상황에서 필요한 고급 Hooks들이 있습니다. 
예를 들어 <code>useLayoutEffect</code>는 DOM 업데이트 직후 동기적으로 실행되고, <code>useId</code>는 서버와 클라이언트 렌더링의 ID 불일치를 해결합니다.</p>
<h4 id="uselayouteffect">useLayoutEffect</h4>
<p><code>useEffect</code>와 유사하지만, DOM 변경 후 브라우저가 화면을 그리기 전에 동기적으로 실행됩니다. </p>
<pre><code class="language-jsx">function MeasureExample() {
  const [height, setHeight] = useState(0);
  const measuredRef = useRef();

  useLayoutEffect(() =&gt; {
    // DOM 조작 후 즉시 측정 (깜빡임 방지)
    if (measuredRef.current) {
      setHeight(measuredRef.current.scrollHeight);
    }
  });

  return (
    &lt;div&gt;
      &lt;div ref={measuredRef}&gt;측정할 내용&lt;/div&gt;
    &lt;/div&gt;
    &lt;p&gt;높이: {height}px&lt;/p&gt;
  &lt;/div&gt;
    );
}</code></pre>
<blockquote>
<p><strong>언제 사용하는 지?</strong></p>
</blockquote>
<ul>
<li>DOM을 조작한 후 즉시 측정이 필요할 때</li>
<li>레이아웃 깜빡임을 방지하고 싶을 때</li>
</ul>
<br />

<h4 id="useid">useId</h4>
<p>하이드레이션 불일치 없이 고유한 ID를 생성합니다. </p>
<pre><code class="language-jsx">function CheckBox() {
  const id = useId();

  return (
    &lt;&gt;
      &lt;label htmlFor={id}&gt;동의합니다&lt;/label&gt;
      &lt;input id={id} type=&quot;checkbox&quot; /&gt;
      &lt;/&gt;
    );
}</code></pre>
<br />

<h4 id="useimperativehandle">useImperativeHandle</h4>
<p><code>forwardRef</code>와 함께 사용하여 부모 컴포넌트에 특정 함수만 노출할 때 사용합니다. </p>
<pre><code class="language-jsx">const FancyInput = forwardRef((props, ref) =&gt; {
  const inputRef = useRef();

  useImperativeHandle(ref, () =&gt; ({
    focus: () =&gt; inputRef.current.focus(),
    clear: () =&gt; inputRef.current.value = ''
  }));

  return &lt;input ref={inputRef} {...props} /&gt;;
});</code></pre>
<br />

<h4 id="useoptimistic">useOptimistic</h4>
<p>낙관적 업데이트를 구현할 때 사용합니다. </p>
<pre><code class="language-jsx">function TodoList() {
  const [todos, setTodos] = useState([]);
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos, 
    (state, newTodo) =&gt; [...state, {...newTodo, pending: true }]
    );

  const addTodo = async (text) =&gt; {
    addOptimisticTodo({ id: Date.now(), text });

    try {
      const newTodo = await saveTodo(text);
      setTodos(prev =&gt; [...prev, newTodo]);
    } catch (error) {
      // 실패 시 롤백
      console.error('할 일 저장 실패:', error);
    }
  };

  return (
    &lt;div&gt;
      {optimisticTodos.map(todo =&gt; (
        &lt;div key={todo.id} className={todo.pending ? 'pending' : ''}&gt;
          {todo.text}
        &lt;/div&gt;
        ))}
      &lt;/div&gt;
    );
}</code></pre>
<br />

<h2 id="5-custom-hooks-만들기">5. Custom Hooks 만들기</h2>
<p>커스텀 훅은 자주 사용하는 상태 로직을 재사용할 수 있는 함수로 추출하는 방법입니다.</p>
<blockquote>
<p><strong>커스텀 훅 규칙</strong></p>
</blockquote>
<ul>
<li>이름은 <code>use</code>로 시작</li>
<li>내부에서 다른 Hooks 호출 가능</li>
</ul>
<pre><code class="language-jsx">// 커스텀 훅 예제
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setStoredValue = (value) =&gt; {
    try {
      setValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('localStorage 저장 실패:', error);
    }
  };

  return [value, setStoredValue];
}

// 사용
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;
      현재 테마: {theme}
    &lt;/button&gt;
  );
}</code></pre>
<h2 id="요약">요약</h2>
<p>지금까지 리액트 훅의 도입 동기, 클래스 컴포넌트와 함수형 컴포넌트 차이, 여러 훅부터 시작해 간단한 커스텀 훅까지 살펴보았습니다. </p>
<blockquote>
<p><strong>핵심 point</strong></p>
</blockquote>
<ul>
<li><code>useState</code>: 상태 관리의 기본</li>
<li><code>useEffect</code>: 생명주기를 하나로 통합</li>
<li><code>useContext</code>: props drilling 해결</li>
<li>커스텀 훅: 로직 재사용의 핵심</li>
</ul>
<p>리액트에서는 이제 클래스 컴포넌트보다 함수형 컴포넌트가 표준이 되어 사용할 것을 권장하고 있고, 이에 맞춰 여러 리액트 훅, 그리고 재사용성을 고려한 커스텀 훅을 만들어 사용이 되고 있습니다. 이번 포스트에서 성능 최적화를 위한 useCallback, useMemo, memo와 같은 훅들을 살펴보았는데 다음 포스트에서는 이어서 리액트 성능 최적화에 대해 다뤄보려 합니다. </p>
